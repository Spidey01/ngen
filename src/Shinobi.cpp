/*
 * Copyright 2019-current Terry Mathew Poulin <BigBoss1964@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "Shinobi.hpp"
#include "Bundle.hpp"

#include <iostream>

using std::endl;

Shinobi::Shinobi(Bundle& bundle)
    : mBundle(bundle)
    , mProjectIndex(SIZE_MAX)
    , mCompileRules({
        { "c_application", "c_compile" },
        { "cxx_application", "cxx_compile" },
        { "cs_application", "cs_compile" },
        { "java_application", "java_compile" },
        { "java_library", "java_compile" },
    })
    , mLinkRules({
        { "c_application", "c_application" },
        { "c_library", "c_library" },
        { "cxx_application", "cxx_application" },
        { "cxx_library", "cxx_library" },
        { "cs_application", "cs_application" },
        { "cs_library", "cs_library" },
        { "java_application", "java_application" },
        { "java_library", "java_library" },
    })
{
}


bool Shinobi::generate()
{
    for (const json& project : projects()) {
        mProjectIndex += 1; // unsigned ftw.

        if (!generateProject(project)) {
            log() << "generateProject failed for project " << project.at("project") << endl;
            return false;
        }
    }

    return true;
}


bool Shinobi::generateProject(const json& project)
{
    if (debug()) {
        log() << "project: ";
        if (has(project, "project")) {
            log() << " name: " << project["project"];
            if (has(project, "version"))
                log() << " version: " << project["version"];
            log() << endl;
        }
    }

    if (!has(project, "type")) {
        error() << "project has no type set." << endl;
        return false;
    }
    if (debug())
        log() << "project " << project.at("project") << " has type " << project.at("type") << endl;

    if (!has(project, "sources")) {
        if (debug())
            log() << "nothing to do for " << project.at("project") << endl;
        return true;
    }

    /*
     * builddir is a ninja variable that defaults to .
     *
     * The rest our Terry Poulin's taste in solving the source -> build -> dist
     * relationship.
     */

    output()
        << "# Generated by ngen {TODO have a version} on {TODO give date/time}" << endl
        << endl
        ;

    if (!generateVariables()) {
        error() << "failed to generate variables" << endl;
        return false;
    }

    if (!generateRules()) {
        error() << "failed to generate rules" << endl;
        return false;
    }

    string type = project.at("type");

    /*
     * Configure the rule for making object files.
     */

    string rule = compileRule(type);

    if (rule.empty()) {
        warning() << "unsupported type: " << type << endl;
    }
    if (!generateBuildStatementsForObjects(project, type, rule)) {
        error() << "failed to generate build statements for objects." << endl;
        return false;
    }

    rule = linkRule(type);
    
    if (type.rfind("_application") != 0) {
        if (!generateBuildStatementsForApplication(project, type, rule)) {
            error() << "failed to generate build statements for applications." << endl;
        }
    } else if (type.rfind("_library") != 0) {
        if (!generateBuildStatementsForLibrary(project, type, rule)) {
            error() << "failed to generate build statements for libraries." << endl;
        }
    } else {
        log() << "TODO: " << type << endl;
    }

    return true;
}


bool Shinobi::generateVariables()
{
    if (debug())
        log() << "generateVariables()" << endl;

    output()
        << "# where the sources can be found." << endl
        << "sourcedir = " << mBundle.sourcedir << endl
        << endl
        << "# where build artifacts go." << endl
        << "builddir = " << mBundle.builddir << endl
        << endl
        << "# where redistributable artifacts go." << endl
        << "distdir = " << mBundle.distdir << endl
        << endl
        ;

    return true;
}


bool Shinobi::generateRules()
{
    if (debug())
        log() << "generateRules()" << endl;

    return true;
}


bool Shinobi::generateBuildStatementsForObjects(const json& project, const string& type, const string& rule)
{
    if (debug())
        log() << "generateBuildStatementsForObjects(): project: " << project.at("project") << " type: " << type << " rule: " << rule << endl;
    return true;
}


bool Shinobi::generateBuildStatementsForApplication(const json& project, const string& type, const string& rule)
{
    if (debug())
        log() << "generateBuildStatementsForApplication(): project: " << project.at("project") << " type: " << type << " rule: " << rule << endl;
    return true;
}


bool Shinobi::generateBuildStatementsForLibrary(const json& project, const string& type, const string& rule)
{
    if (debug())
        log() << "generateBuildStatementsForLibrary(): project: " << project.at("project") << " type: " << type << " rule: " << rule << endl;
    return true;
}


void Shinobi::failure(std::ostream& log)
{
    log << "error in shuriken avoidance algorithm." << endl;
}


std::ostream& Shinobi::log() const
{
    return std::clog;
}


const Shinobi::json& Shinobi::projects() const
{
    return mBundle.data.at("projects");
}


bool Shinobi::has(const json& obj, const string& field)
{
    return obj.find(field) != obj.cend();
}


bool Shinobi::debug() const
{
    return mBundle.debug;
}


const Shinobi::json& Shinobi::data() const
{
    return mBundle.data;
}


std::ostream& Shinobi::error() const
{
    log() << "error: ";

    if (mProjectIndex != SIZE_MAX)
        log() << "project:" << projects().at(mProjectIndex).at("project") << ": ";

    return log();
}


std::ostream& Shinobi::warning() const
{
    log() << "warning: ";

    if (mProjectIndex != SIZE_MAX)
        log() << "project:" << projects().at(mProjectIndex).at("project") << ": ";

    return log();
}

std::ostream& Shinobi::output()
{
    return mBundle.output;
}


Shinobi::string Shinobi::compileRule(const string& type) const
{
    auto it = mCompileRules.find(type);

    if (it == mCompileRules.cend())
        return "";

    return it->second;
}


Shinobi::string Shinobi::linkRule(const string& type) const
{
    auto it = mLinkRules.find(type);

    if (it == mLinkRules.cend())
        return "";

    return it->second;
}
